use core::slice;
use std::{marker::PhantomData, hash::{Hash, Hasher}, iter::{Enumerate, self}, vec::{self}, ops};

struct Index(usize);

trait ArenaPtr {
    fn get_index(self) -> Index;
}

trait ArenaEntry<P: ArenaPtr> {
    fn to_ptr(&self, index: Index) -> P;
    fn is_free(&self) -> bool;
}

#[derive(Debug, Default)]
pub struct Arena<P: ArenaPtr, E: ArenaEntry<P>> {
    entries: Vec<E>,
    free: Vec<usize>,
    _t: PhantomData<P>
}


impl<P: ArenaPtr, E: ArenaEntry<P>> Arena<P, E> {
    #[inline]
    pub fn new() -> Self {
        Self { entries: Vec::new(), free: Vec::new(), _t: PhantomData }
    }

    #[inline]
    pub fn with_capacity(entries_capacity: usize, free_capacity: usize) -> Self {
        Self { entries: Vec::with_capacity(entries_capacity), free: Vec::with_capacity(free_capacity), _t: PhantomData }
    }

    /// Get the number of entries in this arena
    #[inline]
    pub fn len(&self) -> usize {
        self.entries.len() - self.free.len()
    }

    pub fn index(&self, ptr: P) -> E {
        let entry: E = self.entries[ptr.get_index()];
        match entry.is_free() {
            true => panic!(),
            false => entry
        }
    }

    ///
    #[inline]
    pub fn get(&self, ptr: P) -> Option<E> {
        let entry : Option<E> = self.entries.get(ptr);
        match entry {
            Some(entry) =>
                match entry.is_free() {
                    true => None,
                    false => Some(entry),
                }
            None => None,
        }
    }

    #[inline]
    pub fn alloc(&mut self, entry: E) -> P {
        if let Some(index) = self.free.pop() {
            self.entries[index] = entry;
            entry.to_ptr(Index(index))
        }
        else {
            let index = self.entries.len();
            self.entries.push(entry);
            entry.to_ptr(Index(index))
        }
    }

    #[inline]
    pub fn free(&mut self, ptr: P) -> bool {
        match std::mem::replace(&mut self.entries[ptr.get_index()], ArenaEntry::Free(self.free.len())) {
            ArenaEntry::Occupied(entry) => {
                self.free.push(id.index);
                Some(entry)
            },
            ArenaEntry::Free(_) => None,
        }
    }

    #[inline]
    pub fn iter<'a>(&'a self) -> ArenaIter<E, T> {
        IntoIterator::into_iter(self)
    }
}


impl<E: ToTag<T>, T: Copy> Index<Ptr<T>> for Arena<E,T> {
    type Output = E;

    #[inline]
    fn index(&self, index: Ptr<T>) -> &Self::Output {
        self.get(&index).unwrap()
    }
}

pub struct ArenaIter<'a, E: ToTag<T>, T: Copy> {
    iter: iter::Enumerate<slice::Iter<'a, ArenaEntry<E>>>,
    _e: PhantomData<T>
}

impl<'a, E: ToTag<T>, T: Copy> Iterator for ArenaIter<'a, E, T> {
    type Item = Ptr<T>;

    fn next(&mut self) -> Option<Self::Item> {
        loop {
            match self.iter.next() {
                Some((index, ArenaEntry::Occupied(entry))) => return Some(Ptr { index, tag: entry.to_tag() }),
                Some((index, ArenaEntry::Free(..))) => continue,
                None => return None,
            }
        }
    }
}

impl<'a, E: ToTag<T>, T: Copy> IntoIterator for &'a Arena<E, T> {
    type Item = Ptr<T>;
    type IntoIter = ArenaIter<'a, E, T>;

    #[inline]
    fn into_iter(self) -> ArenaIter<'a, E, T> {
        ArenaIter {
            iter: self.entries.iter().enumerate(),
            _e: PhantomData,
        }
    }
}
